//! 9次精度の加重基本的非振動 (WENO) スキームを用いた移流項評価。
//! Borges らによる WENO-Z 重みを用いて滑らかな領域での精度を改善する。
use crate::schemes::Scheme;
use crate::utils::{idx, pid};

pub struct Weno9Z;

const EPS: f64 = 1e-6;
const C: [[f64; 5]; 5] = [
    [0.2734375, -1.40625, 2.953125, -3.28125, 2.4609375],
    [-0.0390625, 0.21875, -0.546875, 1.09375, 0.2734375],
    [0.0234375, -0.15625, 0.703125, 0.46875, -0.0390625],
    [-0.0390625, 0.46875, 0.703125, -0.15625, 0.0234375],
    [0.2734375, 1.09375, -0.546875, 0.21875, -0.0390625],
];
const B: [[[f64; 5]; 5]; 5] = [
    [
        [
            10.059755291005292,
            -46.385548941798945,
            81.7828373015873,
            -65.64804894179895,
            20.19100529100529,
        ],
        [
            -46.385548941798945,
            214.6505291005291,
            -380.20218253968255,
            306.99497354497356,
            -95.05777116402116,
        ],
        [
            81.7828373015873,
            -380.20218253968255,
            677.7761904761904,
            -552.0771825396826,
            172.7203373015873,
        ],
        [
            -65.64804894179895,
            306.99497354497356,
            -552.0771825396826,
            455.7616402116402,
            -145.03138227513227,
        ],
        [
            20.19100529100529,
            -95.05777116402116,
            172.7203373015873,
            -145.03138227513227,
            47.177810846560845,
        ],
    ],
    [
        [
            2.2889219576719575,
            -10.420271164021164,
            17.887003968253968,
            -13.668882275132274,
            3.9132275132275134,
        ],
        [
            -10.420271164021164,
            48.09497354497355,
            -83.74384920634921,
            64.88386243386243,
            -18.814715608465608,
        ],
        [
            17.887003968253968,
            -83.74384920634921,
            148.77619047619046,
            -117.86884920634921,
            34.94950396825397,
        ],
        [
            -13.668882275132274,
            64.88386243386243,
            -117.86884920634921,
            96.76164021164021,
            -30.107771164021162,
        ],
        [
            3.9132275132275134,
            -18.814715608465608,
            34.94950396825397,
            -30.107771164021162,
            10.059755291005292,
        ],
    ],
    [
        [
            1.1153108465608466,
            -4.552215608465609,
            6.782837301587302,
            -4.3702711640211644,
            1.0243386243386243,
        ],
        [
            -4.552215608465609,
            19.928306878306877,
            -31.20218253968254,
            20.82830687830688,
            -5.002215608465608,
        ],
        [
            6.782837301587302,
            -31.20218253968254,
            52.27619047619048,
            -37.07718253968254,
            9.220337301587302,
        ],
        [
            -4.3702711640211644,
            20.82830687830688,
            -37.07718253968254,
            28.150529100529102,
            -7.531382275132275,
        ],
        [
            1.0243386243386243,
            -5.002215608465608,
            9.220337301587302,
            -7.531382275132275,
            2.2889219576719575,
        ],
    ],
    [
        [
            2.2889219576719575,
            -7.531382275132275,
            9.220337301587302,
            -5.002215608465608,
            1.0243386243386243,
        ],
        [
            -7.531382275132275,
            28.150529100529102,
            -37.07718253968254,
            20.82830687830688,
            -4.3702711640211644,
        ],
        [
            9.220337301587302,
            -37.07718253968254,
            52.27619047619048,
            -31.20218253968254,
            6.782837301587302,
        ],
        [
            -5.002215608465608,
            20.82830687830688,
            -31.20218253968254,
            19.928306878306877,
            -4.552215608465609,
        ],
        [
            1.0243386243386243,
            -4.3702711640211644,
            6.782837301587302,
            -4.552215608465609,
            1.1153108465608466,
        ],
    ],
    [
        [
            10.059755291005292,
            -30.107771164021162,
            34.94950396825397,
            -18.814715608465608,
            3.9132275132275134,
        ],
        [
            -30.107771164021162,
            96.76164021164021,
            -117.86884920634921,
            64.88386243386243,
            -13.668882275132274,
        ],
        [
            34.94950396825397,
            -117.86884920634921,
            148.77619047619046,
            -83.74384920634921,
            17.887003968253968,
        ],
        [
            -18.814715608465608,
            64.88386243386243,
            -83.74384920634921,
            48.09497354497355,
            -10.420271164021164,
        ],
        [
            3.9132275132275134,
            -13.668882275132274,
            17.887003968253968,
            -10.420271164021164,
            2.2889219576719575,
        ],
    ],
];
const D: [f64; 5] = [
    1.0 / 126.0,
    10.0 / 63.0,
    5.0 / 18.0,
    10.0 / 63.0,
    1.0 / 126.0,
];

fn reconstruct(arr: &[f64; 9]) -> f64 {
    let mut beta = [0.0; 5];
    let mut cval = [0.0; 5];
    for k in 0..5 {
        let mut ck = 0.0;
        for m in 0..5 {
            ck += C[k][m] * arr[k + m];
        }
        cval[k] = ck;
        let vals = &arr[k..k + 5];
        let mut b = 0.0;
        for i in 0..5 {
            for j in 0..5 {
                b += B[k][i][j] * vals[i] * vals[j];
            }
        }
        beta[k] = b;
    }
    let tau = (beta[0] - beta[4]).abs();
    let mut alpha = [0.0; 5];
    let mut sum = 0.0;
    for k in 0..5 {
        alpha[k] = D[k] * (1.0 + (tau / (beta[k] + EPS)).powi(2));
        sum += alpha[k];
    }
    let mut w = [0.0; 5];
    for k in 0..5 {
        w[k] = alpha[k] / sum;
    }
    w.iter().zip(cval.iter()).map(|(w, c)| w * c).sum()
}

fn weno9z_fd_flux_faces_1d(f: &[f64], q: &[f64], alpha: f64) -> Vec<f64> {
    let n = f.len();
    let mut fp = vec![0.0; n];
    let mut fm = vec![0.0; n];
    for i in 0..n {
        fp[i] = 0.5 * (f[i] + alpha * q[i]);
        fm[i] = 0.5 * (f[i] - alpha * q[i]);
    }
    let mut fh = vec![0.0; n];
    for i in 0..n {
        let mut arrp = [0.0; 9];
        for k in 0..9 {
            arrp[k] = fp[pid(i as isize + k as isize - 4, n)];
        }
        let fph = reconstruct(&arrp);
        let mut arrm = [0.0; 9];
        for k in 0..9 {
            arrm[k] = fm[pid(i as isize + 5 - k as isize, n)];
        }
        let fmh = reconstruct(&arrm);
        fh[i] = fph + fmh;
    }
    fh
}

impl Scheme for Weno9Z {
    fn rhs(
        &self,
        q: &[f64],
        u: &[f64],
        v: &[f64],
        dx: f64,
        dy: f64,
        nx: usize,
        ny: usize,
        out: &mut [f64],
    ) {
        let mut dfx = vec![0.0; nx * ny];
        for j in 0..ny {
            let mut f = vec![0.0; nx];
            let mut qq = vec![0.0; nx];
            let mut amax = 0.0;
            for i in 0..nx {
                let k = idx(i, j, nx);
                f[i] = u[k] * q[k];
                qq[i] = q[k];
                let a = u[k].abs();
                if a > amax {
                    amax = a;
                }
            }
            let fh = weno9z_fd_flux_faces_1d(&f, &qq, amax);
            for i in 0..nx {
                let im = pid(i as isize - 1, nx);
                dfx[idx(i, j, nx)] = (fh[i] - fh[im]) / dx;
            }
        }
        let mut dfy = vec![0.0; nx * ny];
        for i in 0..nx {
            let mut g = vec![0.0; ny];
            let mut qq = vec![0.0; ny];
            let mut amax = 0.0;
            for j in 0..ny {
                let k = idx(i, j, nx);
                g[j] = v[k] * q[k];
                qq[j] = q[k];
                let a = v[k].abs();
                if a > amax {
                    amax = a;
                }
            }
            let gh = weno9z_fd_flux_faces_1d(&g, &qq, amax);
            for j in 0..ny {
                let jm = pid(j as isize - 1, ny);
                dfy[idx(i, j, nx)] = (gh[j] - gh[jm]) / dy;
            }
        }
        for k in 0..nx * ny {
            out[k] = -(dfx[k] + dfy[k]);
        }
    }
}
