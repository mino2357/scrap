//! Shared core for WENO9-family reconstructions (coefficients and beta).
//! Provides the candidate polynomial values (`cval`) and smoothness
//! indicators (`beta`) for a 9-point stencil.

pub const EPS: f64 = 1e-6;

pub const D: [f64; 5] = [
    1.0 / 126.0,
    10.0 / 63.0,
    5.0 / 18.0,
    10.0 / 63.0,
    1.0 / 126.0,
];

// Linear reconstruction coefficients C[k][m] generated from
// Lagrange interpolation on each 5-point substencil evaluated at x=+1/2.
// Substencil k uses nodes x_j = (k + j - 4), j=0..4, and the weight is
//   C[k][j] = ∏_{t≠j} (0.5 - x_t) / (x_j - x_t).
const fn gen_c() -> [[f64; 5]; 5] {
    let mut out = [[0.0; 5]; 5];
    let mut k = 0;
    while k < 5 {
        // node positions for substencil k
        let mut x = [0.0; 5];
        let mut m = 0;
        while m < 5 {
            x[m] = (k as isize + m as isize - 4) as f64;
            m += 1;
        }
        let xe = 0.5f64;
        let mut j = 0;
        while j < 5 {
            let mut num = 1.0f64;
            let mut den = 1.0f64;
            let xj = x[j];
            let mut t = 0;
            while t < 5 {
                if t != j {
                    num *= xe - x[t];
                    den *= xj - x[t];
                }
                t += 1;
            }
            out[k][j] = num / den;
            j += 1;
        }
        k += 1;
    }
    out
}

const C: [[f64; 5]; 5] = gen_c();

const B: [[[f64; 5]; 5]; 5] = [
    [
        [304207.0/30240.0, -1402699.0/30240.0, 824371.0/10080.0, -1985197.0/30240.0, 38161.0/1890.0],
        [-1402699.0/30240.0, 811379.0/3780.0, -1916219.0/5040.0, 1160441.0/3780.0, -2874547.0/30240.0],
        [824371.0/10080.0, -1916219.0/5040.0, 142333.0/210.0, -2782469.0/5040.0, 1741021.0/10080.0],
        [-1985197.0/30240.0, 1160441.0/3780.0, -2782469.0/5040.0, 1722779.0/3780.0, -4385749.0/30240.0],
        [38161.0/1890.0, -2874547.0/30240.0, 1741021.0/10080.0, -4385749.0/30240.0, 1426657.0/30240.0],
    ],
    [
        [69217.0/30240.0, -315109.0/30240.0, 180301.0/10080.0, -413347.0/30240.0, 3698.0/945.0],
        [-315109.0/30240.0, 181799.0/3780.0, -422069.0/5040.0, 245261.0/3780.0, -568957.0/30240.0],
        [180301.0/10080.0, -422069.0/5040.0, 31243.0/210.0, -594059.0/5040.0, 352291.0/10080.0],
        [-413347.0/30240.0, 245261.0/3780.0, -594059.0/5040.0, 365759.0/3780.0, -910459.0/30240.0],
        [3698.0/945.0, -568957.0/30240.0, 352291.0/10080.0, -910459.0/30240.0, 304207.0/30240.0],
    ],
    [
        [33727.0/30240.0, -137659.0/30240.0, 68371.0/10080.0, -132157.0/30240.0, 968.0/945.0],
        [-137659.0/30240.0, 75329.0/3780.0, -157259.0/5040.0, 78731.0/3780.0, -151267.0/30240.0],
        [68371.0/10080.0, -157259.0/5040.0, 5489.0/105.0, -186869.0/5040.0, 92941.0/10080.0],
        [-132157.0/30240.0, 78731.0/3780.0, -186869.0/5040.0, 106409.0/3780.0, -227749.0/30240.0],
        [968.0/945.0, -151267.0/30240.0, 92941.0/10080.0, -227749.0/30240.0, 69217.0/30240.0],
    ],
    [
        [69217.0/30240.0, -227749.0/30240.0, 92941.0/10080.0, -151267.0/30240.0, 968.0/945.0],
        [-227749.0/30240.0, 106409.0/3780.0, -186869.0/5040.0, 78731.0/3780.0, -132157.0/30240.0],
        [92941.0/10080.0, -186869.0/5040.0, 5489.0/105.0, -157259.0/5040.0, 68371.0/10080.0],
        [-151267.0/30240.0, 78731.0/3780.0, -157259.0/5040.0, 75329.0/3780.0, -137659.0/30240.0],
        [968.0/945.0, -132157.0/30240.0, 68371.0/10080.0, -137659.0/30240.0, 33727.0/30240.0],
    ],
    [
        [304207.0/30240.0, -910459.0/30240.0, 352291.0/10080.0, -568957.0/30240.0, 3698.0/945.0],
        [-910459.0/30240.0, 365759.0/3780.0, -594059.0/5040.0, 245261.0/3780.0, -413347.0/30240.0],
        [352291.0/10080.0, -594059.0/5040.0, 31243.0/210.0, -422069.0/5040.0, 180301.0/10080.0],
        [-568957.0/30240.0, 245261.0/3780.0, -422069.0/5040.0, 181799.0/3780.0, -315109.0/30240.0],
        [3698.0/945.0, -413347.0/30240.0, 180301.0/10080.0, -315109.0/30240.0, 69217.0/30240.0],
    ],
];

/// Compute candidate polynomial values and smoothness indicators for a 9-point array
/// centered at face i+1/2 in the positive-flux orientation.
#[inline]
pub fn cvals_betas(arr: &[f64; 9]) -> ([f64; 5], [f64; 5]) {
    let mut beta = [0.0; 5];
    let mut cval = [0.0; 5];
    for k in 0..5 {
        let mut ck = 0.0;
        for m in 0..5 {
            ck += C[k][m] * arr[k + m];
        }
        cval[k] = ck;
        let vals = &arr[k..k + 5];
        let mut b = 0.0;
        for i in 0..5 {
            for j in 0..5 {
                b += B[k][i][j] * vals[i] * vals[j];
            }
        }
        beta[k] = b;
    }
    (cval, beta)
}
